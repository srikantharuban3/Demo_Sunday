name: AI-Powered Test Execution

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      browser:
        description: 'Browser to use for testing'
        required: false
        default: 'chromium'
        type: choice
        options:
          - chromium
          - firefox
          - webkit

jobs:
  ai-test-execution:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: üîÑ Checkout Repository
      uses: actions/checkout@v4
      
    - name: üü¢ Setup Node.js 18
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: üì¶ Install Dependencies
      run: |
        npm init -y
        npm install playwright @playwright/test moment fs-extra
        
    - name: üé≠ Install Playwright Browsers
      run: npx playwright install --with-deps
      
    - name: ü§ñ Create AI Test Executor
      run: |
        cat > ai-test-executor.js << 'EOF'
        const { chromium, firefox, webkit } = require('playwright');
        const fs = require('fs-extra');
        const moment = require('moment');
        
        class AITestExecutor {
          constructor() {
            this.browser = null;
            this.page = null;
            this.testResults = [];
            this.startTime = moment();
            this.config = {
              browser: process.env.BROWSER || 'chromium',
              headless: true,
              timeout: 30000
            };
          }
          
          async initialize() {
            console.log('üöÄ Initializing AI Test Executor...');
            console.log(`üìä Browser: ${this.config.browser}`);
            
            const browsers = { chromium, firefox, webkit };
            this.browser = await browsers[this.config.browser].launch({
              headless: this.config.headless,
              args: ['--no-sandbox', '--disable-setuid-sandbox']
            });
            
            this.page = await this.browser.newPage();
            await this.page.setViewportSize({ width: 1920, height: 1080 });
            await fs.ensureDir('test-results');
            await fs.ensureDir('test-results/screenshots');
          }
          
          async executeTestSuite() {
            try {
              console.log('üìã Reading test suite from Testsuite.md...');
              const testSuite = await fs.readFile('Testsuite.md', 'utf8');
              const testCases = this.parseTestCases(testSuite);
              
              console.log(`üîç Found ${testCases.length} test case(s) to execute`);
              
              for (const testCase of testCases) {
                await this.executeTestCase(testCase);
              }
              
              await this.generateReport();
              await this.cleanup();
              
            } catch (error) {
              console.error('‚ùå Fatal error:', error);
              await this.takeScreenshot('fatal-error');
              throw error;
            }
          }
          
          parseTestCases(markdown) {
            const testCases = [];
            const lines = markdown.split('\n');
            let currentTest = null;
            let inTestSuite = false;
            
            for (const line of lines) {
              const trimmedLine = line.trim();
              
              if (trimmedLine.toLowerCase().includes('# test suite')) {
                inTestSuite = true;
                continue;
              }
              
              if (inTestSuite && trimmedLine.match(/^## TC \d+/)) {
                if (currentTest) testCases.push(currentTest);
                
                const tcMatch = trimmedLine.match(/TC (\d+)/);
                const description = trimmedLine.replace(/^## TC \d+ - /, '');
                
                currentTest = {
                  id: `TC${tcMatch[1].padStart(3, '0')}`,
                  title: description,
                  steps: [],
                  priority: this.extractPriority(description)
                };
              } else if (currentTest && trimmedLine.startsWith('- ')) {
                currentTest.steps.push(trimmedLine.substring(2));
              }
            }
            
            if (currentTest) testCases.push(currentTest);
            return testCases;
          }
          
          extractPriority(description) {
            if (description.toLowerCase().includes('critical')) return 'HIGH';
            if (description.toLowerCase().includes('register')) return 'MEDIUM';
            return 'LOW';
          }
          
          async executeTestCase(testCase) {
            console.log(`\nüß™ Executing ${testCase.id}: ${testCase.title}`);
            
            const result = {
              id: testCase.id,
              title: testCase.title,
              priority: testCase.priority,
              status: 'PASS',
              startTime: moment(),
              steps: [],
              error: null,
              screenshots: []
            };
            
            try {
              for (let i = 0; i < testCase.steps.length; i++) {
                const step = testCase.steps[i];
                console.log(`  üìù Step ${i + 1}: ${step}`);
                
                await this.executeStep(step, testCase.id, i + 1);
                result.steps.push({
                  number: i + 1,
                  description: step,
                  status: 'PASS',
                  timestamp: moment().format('HH:mm:ss')
                });
              }
            } catch (error) {
              console.error(`  ‚ùå Test failed: ${error.message}`);
              result.status = 'FAIL';
              result.error = error.message;
              
              const screenshotName = `${testCase.id}-error`;
              await this.takeScreenshot(screenshotName);
              result.screenshots.push(screenshotName);
              
              result.steps.push({
                number: result.steps.length + 1,
                description: 'Test failed',
                status: 'FAIL',
                error: error.message,
                timestamp: moment().format('HH:mm:ss')
              });
            }
            
            result.endTime = moment();
            result.duration = result.endTime.diff(result.startTime, 'seconds');
            
            console.log(`  ${result.status === 'PASS' ? '‚úÖ' : '‚ùå'} ${testCase.id} completed in ${result.duration}s`);
            this.testResults.push(result);
          }
          
          async executeStep(step, testId, stepNum) {
            await this.page.waitForTimeout(1000);
            
            try {
              if (step.toLowerCase().includes('navigate')) {
                await this.handleNavigation(step);
              } else if (step.toLowerCase().includes('click')) {
                await this.handleClick(step);
              } else if (step.toLowerCase().includes('fill')) {
                await this.handleFormFilling(step);
              } else if (step.toLowerCase().includes('submit')) {
                await this.handleSubmit(step);
              } else if (step.toLowerCase().includes('verify')) {
                await this.handleVerification(step);
              } else {
                console.log(`  ‚ö†Ô∏è  Unknown step type: ${step}`);
              }
              
              if (stepNum % 2 === 0) {
                await this.takeScreenshot(`${testId}-step${stepNum}`);
              }
              
            } catch (error) {
              const pageUrl = this.page.url();
              const pageTitle = await this.page.title().catch(() => 'Unknown');
              throw new Error(`Step failed on "${pageTitle}" (${pageUrl}): ${error.message}`);
            }
          }
          
          async handleNavigation(step) {
            const urlMatch = step.match(/`([^`]+)`/) || step.match(/https?:\/\/[^\s]+/);
            if (urlMatch) {
              const url = urlMatch[1] || urlMatch[0];
              console.log(`    üåê Navigating to: ${url}`);
              await this.page.goto(url, { waitUntil: 'networkidle', timeout: this.config.timeout });
            }
          }
          
          async handleClick(step) {
            const clickTargets = [
              { pattern: /register/i, selectors: ['a[href*="register"]', 'button:has-text("Register")', '.register'] },
              { pattern: /login/i, selectors: ['a[href*="login"]', 'button:has-text("Login")', '.login'] },
              { pattern: /submit/i, selectors: ['input[type="submit"]', 'button[type="submit"]'] }
            ];
            
            for (const target of clickTargets) {
              if (target.pattern.test(step)) {
                for (const selector of target.selectors) {
                  try {
                    await this.page.click(selector, { timeout: this.config.timeout });
                    console.log(`    üëÜ Clicked: ${selector}`);
                    return;
                  } catch (e) {
                    continue;
                  }
                }
              }
            }
            
            throw new Error(`Could not find element to click for: ${step}`);
          }
          
          async handleFormFilling(step) {
            console.log(`    üìù Filling form fields...`);
            
            const timestamp = Date.now();
            const uniqueId = Math.random().toString(36).substring(2, 8);
            
            const testData = {
              firstName: 'John',
              lastName: 'Doe',
              username: `user${timestamp}`.substring(0, 10),
              email: `test${uniqueId}@example.com`,
              password: 'TestPass123!',
              phone: '555-0123',
              ssn: '123-45-6789',
              address: '123 Test Street',
              city: 'Test City',
              state: 'CA',
              zipCode: '12345'
            };
            
            const fieldMappings = [
              { patterns: ['firstName', 'first'], value: testData.firstName },
              { patterns: ['lastName', 'last'], value: testData.lastName },
              { patterns: ['username', 'user'], value: testData.username },
              { patterns: ['email'], value: testData.email },
              { patterns: ['password'], value: testData.password },
              { patterns: ['phone'], value: testData.phone },
              { patterns: ['ssn'], value: testData.ssn },
              { patterns: ['address', 'street'], value: testData.address },
              { patterns: ['city'], value: testData.city },
              { patterns: ['state'], value: testData.state },
              { patterns: ['zip'], value: testData.zipCode }
            ];
            
            for (const mapping of fieldMappings) {
              for (const pattern of mapping.patterns) {
                const selectors = [
                  `input[name*="${pattern}"]`,
                  `input[id*="${pattern}"]`,
                  `input[placeholder*="${pattern}"]`,
                  `input[class*="${pattern}"]`
                ];
                
                for (const selector of selectors) {
                  try {
                    await this.page.fill(selector, mapping.value);
                    console.log(`      ‚úì Filled ${pattern}: ${mapping.value}`);
                    break;
                  } catch (e) {
                    continue;
                  }
                }
              }
            }
            
            // Handle repeat password
            const repeatSelectors = ['input[name*="repeat"]', 'input[name*="confirm"]'];
            for (const selector of repeatSelectors) {
              try {
                await this.page.fill(selector, testData.password);
                console.log(`      ‚úì Filled repeat password`);
                break;
              } catch (e) {
                continue;
              }
            }
          }
          
          async handleSubmit(step) {
            const submitSelectors = [
              'input[type="submit"]',
              'button[type="submit"]',
              'button:has-text("Register")',
              'button:has-text("Submit")',
              '.submit',
              '.register'
            ];
            
            for (const selector of submitSelectors) {
              try {
                await this.page.click(selector);
                console.log(`    üöÄ Form submitted: ${selector}`);
                await this.page.waitForTimeout(3000);
                return;
              } catch (e) {
                continue;
              }
            }
            
            throw new Error('Could not find submit button');
          }
          
          async handleVerification(step) {
            if (step.toLowerCase().includes('welcome')) {
              const welcomeSelectors = [
                'h1:has-text("Welcome")',
                '.welcome',
                'h1.title',
                '[class*="welcome"]'
              ];
              
              for (const selector of welcomeSelectors) {
                try {
                  await this.page.waitForSelector(selector, { timeout: 10000 });
                  const text = await this.page.textContent(selector);
                  if (text && text.toLowerCase().includes('welcome')) {
                    console.log(`    ‚úÖ Welcome message verified: "${text}"`);
                    return;
                  }
                } catch (e) {
                  continue;
                }
              }
              
              throw new Error('Welcome message not found or does not contain expected text');
            }
          }
          
          async takeScreenshot(name) {
            try {
              const screenshotPath = `test-results/screenshots/${name}-${moment().format('YYYY-MM-DD-HH-mm-ss')}.png`;
              await this.page.screenshot({ path: screenshotPath, fullPage: true });
              console.log(`    üì∏ Screenshot saved: ${screenshotPath}`);
              return screenshotPath;
            } catch (error) {
              console.error(`Failed to take screenshot: ${error.message}`);
            }
          }
          
          async generateReport() {
            const endTime = moment();
            const totalDuration = endTime.diff(this.startTime, 'seconds');
            const passedTests = this.testResults.filter(r => r.status === 'PASS').length;
            const failedTests = this.testResults.filter(r => r.status === 'FAIL').length;
            const successRate = ((passedTests / this.testResults.length) * 100).toFixed(1);
            
            const reportHtml = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>AI Test Execution Report</title>
              <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
              <style>
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body { 
                  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  min-height: 100vh;
                  padding: 20px;
                }
                .container { 
                  max-width: 1200px; 
                  margin: 0 auto; 
                  background: white;
                  border-radius: 15px;
                  box-shadow: 0 20px 40px rgba(0,0,0,0.1);
                  overflow: hidden;
                }
                .header { 
                  background: linear-gradient(45deg, #2196F3, #21CBF3);
                  color: white;
                  padding: 30px;
                  text-align: center;
                }
                .header h1 { font-size: 2.5em; margin-bottom: 10px; }
                .stats-grid { 
                  display: grid; 
                  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                  gap: 20px;
                  padding: 30px;
                  background: #f8f9fa;
                }
                .stat-card { 
                  background: white;
                  padding: 25px;
                  border-radius: 10px;
                  text-align: center;
                  box-shadow: 0 5px 15px rgba(0,0,0,0.08);
                  transition: transform 0.3s;
                }
                .stat-card:hover { transform: translateY(-5px); }
                .stat-value { font-size: 2.2em; font-weight: bold; margin-bottom: 10px; }
                .stat-label { color: #666; font-size: 1.1em; }
                .pass { color: #4CAF50; }
                .fail { color: #f44336; }
                .chart-container { 
                  padding: 30px;
                  display: flex;
                  justify-content: center;
                }
                .chart-wrapper { 
                  width: 400px;
                  height: 400px;
                  background: white;
                  padding: 20px;
                  border-radius: 10px;
                  box-shadow: 0 5px 15px rgba(0,0,0,0.08);
                }
                .test-results { padding: 30px; }
                .test-case { 
                  margin: 20px 0;
                  padding: 20px;
                  border-radius: 10px;
                  box-shadow: 0 5px 15px rgba(0,0,0,0.08);
                  background: white;
                }
                .test-case.pass { border-left: 5px solid #4CAF50; }
                .test-case.fail { border-left: 5px solid #f44336; }
                .test-title { font-size: 1.3em; font-weight: bold; margin-bottom: 10px; }
                .test-meta { color: #666; margin-bottom: 15px; }
                .steps { margin-top: 15px; }
                .step { 
                  padding: 10px 15px;
                  margin: 8px 0;
                  border-radius: 5px;
                  background: #f8f9fa;
                  border-left: 3px solid #ddd;
                }
                .step.pass { background: #f8fff8; border-left-color: #4CAF50; }
                .step.fail { background: #fff8f8; border-left-color: #f44336; }
                .error { 
                  background: #ffebee;
                  padding: 15px;
                  border-radius: 5px;
                  margin-top: 10px;
                  color: #c62828;
                  font-weight: bold;
                }
                .badge { 
                  padding: 4px 12px;
                  border-radius: 20px;
                  font-size: 0.8em;
                  font-weight: bold;
                  text-transform: uppercase;
                }
                .badge.high { background: #ffebee; color: #c62828; }
                .badge.medium { background: #fff3e0; color: #ef6c00; }
                .badge.low { background: #e8f5e8; color: #2e7d32; }
              </style>
            </head>
            <body>
              <div class="container">
                <div class="header">
                  <h1>ü§ñ AI Test Execution Report</h1>
                  <p>Generated on ${moment().format('MMMM Do YYYY, h:mm:ss a')}</p>
                  <p>Browser: ${this.config.browser.toUpperCase()} | Duration: ${totalDuration}s | Success Rate: ${successRate}%</p>
                </div>
                
                <div class="stats-grid">
                  <div class="stat-card">
                    <div class="stat-value">${this.testResults.length}</div>
                    <div class="stat-label">Total Tests</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-value pass">${passedTests}</div>
                    <div class="stat-label">Passed</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-value fail">${failedTests}</div>
                    <div class="stat-label">Failed</div>
                  </div>
                  <div class="stat-card">
                    <div class="stat-value">${totalDuration}s</div>
                    <div class="stat-label">Duration</div>
                  </div>
                </div>
                
                <div class="chart-container">
                  <div class="chart-wrapper">
                    <h3 style="text-align: center; margin-bottom: 20px;">Test Results</h3>
                    <canvas id="resultsChart"></canvas>
                  </div>
                </div>
                
                <div class="test-results">
                  <h2>üìã Detailed Test Results</h2>
                  ${this.testResults.map(result => `
                    <div class="test-case ${result.status.toLowerCase()}">
                      <div class="test-title">
                        ${result.status === 'PASS' ? '‚úÖ' : '‚ùå'} ${result.id} - ${result.title}
                        <span class="badge ${result.priority.toLowerCase()}" style="margin-left: 10px;">${result.priority}</span>
                      </div>
                      <div class="test-meta">
                        Status: <strong>${result.status}</strong> | 
                        Duration: <strong>${result.duration}s</strong> | 
                        Started: ${result.startTime.format('HH:mm:ss')}
                        ${result.screenshots.length > 0 ? ` | Screenshots: ${result.screenshots.length}` : ''}
                      </div>
                      
                      <div class="steps">
                        <strong>Test Steps:</strong>
                        ${result.steps.map(step => `
                          <div class="step ${step.status.toLowerCase()}">
                            <strong>Step ${step.number}:</strong> ${step.description}
                            <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                              Time: ${step.timestamp}
                              ${step.error ? `<br><span style="color: #f44336;">Error: ${step.error}</span>` : ''}
                            </div>
                          </div>
                        `).join('')}
                      </div>
                      
                      ${result.error ? `
                        <div class="error">
                          üí• Test Error: ${result.error}
                        </div>
                      ` : ''}
                    </div>
                  `).join('')}
                </div>
              </div>
              
              <script>
                const ctx = document.getElementById('resultsChart').getContext('2d');
                new Chart(ctx, {
                  type: 'doughnut',
                  data: {
                    labels: ['Passed', 'Failed'],
                    datasets: [{
                      data: [${passedTests}, ${failedTests}],
                      backgroundColor: ['#4CAF50', '#f44336'],
                      borderWidth: 0,
                      hoverBorderWidth: 3
                    }]
                  },
                  options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                      legend: { 
                        position: 'bottom',
                        labels: { padding: 20, font: { size: 14 } }
                      }
                    }
                  }
                });
              </script>
            </body>
            </html>`;
            
            await fs.writeFile('test-results/ai-test-report.html', reportHtml);
            
            console.log(`\nüìä Test execution completed!`);
            console.log(`üìà Success Rate: ${successRate}%`);
            console.log(`‚è±Ô∏è  Total Duration: ${totalDuration} seconds`);
            console.log(`üìã Report: test-results/ai-test-report.html`);
            
            if (failedTests > 0) {
              process.exit(1);
            }
          }
          
          async cleanup() {
            if (this.browser) {
              await this.browser.close();
            }
          }
        }
        
        // Execute the test suite
        const executor = new AITestExecutor();
        executor.initialize()
          .then(() => executor.executeTestSuite())
          .catch(error => {
            console.error('üí• Test execution failed:', error);
            process.exit(1);
          });
        EOF
        
    - name: üöÄ Execute AI Tests
      env:
        BROWSER: ${{ github.event.inputs.browser || 'chromium' }}
      run: node ai-test-executor.js
      
    - name: üìä Upload Test Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: ai-test-results-${{ github.event.inputs.browser || 'chromium' }}
        path: test-results/
        
    - name: üí¨ Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          try {
            const reportExists = fs.existsSync('test-results/ai-test-report.html');
            if (reportExists) {
              const comment = `
              ## ü§ñ AI Test Execution Results
              
              The AI-powered test suite has completed execution using **${{ github.event.inputs.browser || 'chromium' }}** browser.
              
              üìä **Test Report:** Available in workflow artifacts
              üîó **Workflow Run:** [View Details](${context.payload.pull_request.html_url}/checks)
              üåê **Browser:** ${{ github.event.inputs.browser || 'chromium' }}
              
              Download the test report from the artifacts section to view detailed results with charts and screenshots.
              `;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
          } catch (error) {
            console.log('Could not post test results comment:', error.message);
          }